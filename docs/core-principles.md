## Core Principles.

ui-lib is an SSR-first, type-safe component library that embraces

✅ SSR-first - Components render on server ✅ JSX only - Using h() function and
JSX syntax ✅ CSS-in-TS - All styling through css() and composeStyles() ✅
DOM-based state - State lives in data attributes and CSS classes ✅ Collocated
APIs - API handlers defined within components ✅ Three-tier reactivity -
Immediate DOM updates + HTMX + custom events

### 1) SSR-first with Progressive Enhancement

- The server returns HTML; clients submit forms or JSON and receive HTML
  fragments in response.
- Works without client-side JavaScript; optional enhancement uses HTMX-style
  attributes generated by helpers.
- No hydration costs; markup is ready to display as delivered.

### 2) JSX-only in application code

- Write components and pages using JSX/TSX. The JSX factory is provided by
  ui-lib (`h`).
- The internal render pipeline (e.g., `renderComponent`) is library-only; do not
  call it from application code.
- Outcome: strongly typed, ergonomic, and composable markup.

### 3) DOM-native state (the DOM is the source of truth)

- Use:
  - CSS classes for boolean state
  - Data attributes for structured values
  - Element content for display values
  - CSS custom properties (variables) for theme and tokens
- Eliminates client memory stores by default; state is visible and inspectable
  in DevTools.

### 4) Zero runtime by default

- No client-side framework required for core functionality.
- Optional client helpers are small and focused (<10KB typical) and only used
  when needed.
- First paint is fast; nothing blocks on hydration.

### 5) End-to-end type safety

- Strict TypeScript everywhere: components, helpers, and props parsing.
- Props are inlined in the render function; Prop helpers convert string
  attributes into typed values safely.
- Safer refactors and better editor guidance.

### 6) Light Functional Programming (Light FP)

- Pure functions for core logic; push side effects to the edges.
- Immutable public data types (use `type` with `readonly`), treat errors as
  values (`Result<T,E>`), and inject dependencies via function parameters
  (ports).
- No classes or inheritance in core logic.

### 7) Token-based customization and CSS-in-TS

- Components expose styling via design tokens and CSS custom properties.
- A CSS-in-TS utility (`css()`) generates collision-free class names.
- Variants and sizes are selected via props, not inline styles.

### 8) API collocated with components

- Components may declare server endpoints alongside their UI, keeping behavior
  and transport close together.
- API definitions are simple tuples: `[method, path, handler]`.

Example:

```tsx
import {
  boolean,
  defineComponent,
  h,
  html,
  number,
  on,
  publishState,
  type RouteHandlerFor,
  string,
  subscribeToState,
} from "../mod.ts";
import { err, ok, type Result } from "../lib/result.ts";

// --- Light FP domain (no classes, errors as values) ---
export type Counter = { readonly id: string; readonly count: number };
export type CounterError =
  | { readonly type: "invalid_payload"; readonly message: string }
  | { readonly type: "not_found"; readonly message: string };

const incrementCounter = (c: Counter): Result<Counter, CounterError> =>
  ok({ ...c, count: c.count + 1 });
const resetCounter = (c: Counter): Result<Counter, CounterError> =>
  ok({ ...c, count: 0 });

// Minimal in-memory store for demo purposes
const counters = new Map<string, Counter>();

// --- API handlers colocated with the component ---
const incrementHandler: RouteHandlerFor<"/api/counter/:id/increment"> = async (
  _req,
  params,
) => {
  const current = counters.get(params.id) ?? { id: params.id, count: 0 };
  const next = incrementCounter(current);
  if (!next.ok) return html("<div>Invalid</div>", { status: 400 });
  counters.set(params.id, next.value);
  // Return a small HTML fragment (HTMX swaps it in)
  return html(`<span data-count>${next.value.count}</span>`);
};

const resetHandler: RouteHandlerFor<"/api/counter/:id/reset"> = async (
  _req,
  params,
) => {
  const current = counters.get(params.id) ?? { id: params.id, count: 0 };
  const next = resetCounter(current);
  if (!next.ok) return html("<div>Invalid</div>", { status: 400 });
  counters.set(params.id, next.value);
  return html(`<span data-count>${next.value.count}</span>`);
};

// --- Comprehensive component using SSR, JSX, inline prop parsing, reactivity, and collocated API ---
export const Counter = defineComponent("counter", {
  // Reactivity: DOM events, pub/sub state, lifecycle, and CSS properties
  reactive: {
    on: {
      // Custom event to toggle accent color using CSS custom property
      "ui-lib:toggle-accent":
        `document.documentElement.style.setProperty('--accent', getComputedStyle(document.documentElement).getPropertyValue('--accent')?.trim()==='#4f46e5' ? '#16a34a' : '#4f46e5')`,
    },
    state: {
      // Update count when external state publishes to 'counter:update'
      "counter:update":
        "const el=this.querySelector('[data-count]'); if(el){ el.textContent=String(data.count) }",
    },
    mount: `this.style.setProperty('--accent', '#4f46e5')`,
    inject: true,
  },

  // Styles (Unified object → classMap is provided to render)
  styles: {
    root: { display: "inline-flex", alignItems: "center", gap: "0.5rem" },
    label: { fontWeight: "600", color: "var(--accent)" },
    button: {
      padding: "0.375rem 0.625rem",
      border: "1px solid #e5e7eb",
      borderRadius: "0.5rem",
      backgroundColor: "white",
      cursor: "pointer",
      transition: "background-color 150ms ease",
    },
    count: { minWidth: "2rem", textAlign: "center" },
    // Pseudo selector variant expressed as a raw CSS rule
    buttonHover: ".button:hover { background-color: #f9fafb }",
  },

  // API collocated with the component
  api: {
    increment: ["POST", "/api/counter/:id/increment", incrementHandler],
    reset: ["POST", "/api/counter/:id/reset", resetHandler],
  },

  // Inline props parsing and validation via render parameter defaults
  render: (
    {
      id = string(), // required
      label = string("Counter"), // optional with default
      start = number(0), // number coercion
      disabled = boolean(false), // presence boolean
    },
    api,
    classes,
  ) => {
    // Initialize store on first render (SSR-safe, idempotent)
    if (!counters.has(id)) counters.set(id, { id, count: start });

    const attrs = disabled ? { disabled: "true" } : {};

    return (
      <div class={`${classes?.root ?? ""}`} data-id={id}>
        <span class={`${classes?.label ?? ""}`}>{label}</span>
        <button class={`${classes?.button ?? ""}`} {...attrs}>
          −
        </button>
        <span class={`${classes?.count ?? ""}`} data-count>
          {String(counters.get(id)?.count ?? start)}
        </span>
        <button
          class={`${classes?.button ?? ""}`}
          {...api?.increment?.(id)}
          {...attrs}
        >
          +
        </button>
        <button
          class={`${classes?.button ?? ""}`}
          {...api?.reset?.(id)}
          {...attrs}
        >
          Reset
        </button>
      </div>
    );
  },
});
```

---

These principles work together: JSX makes templates type-safe, SSR delivers HTML
immediately, DOM-native state keeps UIs simple and debuggable, Light FP
encourages pure and testable core logic, and token-driven styling keeps
components customizable without leaking implementation details.
