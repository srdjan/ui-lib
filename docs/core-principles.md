DO NOT CHANGE - ONLY manual changes ALLOWED

## Core Principles.

**ui-lib** is an ultra-lightweight, type-safe component library that embraces

✅ SSR-first - Components render on server

- The server returns HTML; clients submit forms or JSON and receive HTML
  fragments in response.
- Works without client-side JavaScript; optional enhancement uses HTMX-style
  attributes generated by helpers.
- No hydration costs; markup is ready to display as delivered.

✅ JSX only - Using h() function and JSX syntax

- Write components and pages using JSX/TSX. The JSX factory is provided by
  ui-lib (`h`).
- The internal render pipeline (e.g., `renderComponent`) is library-only; do not
  call it from application code.
- Outcome: strongly typed, ergonomic, and composable markup.

✅ DOM-native state (the DOM is the source of truth)

- Use:
  - CSS classes for boolean state
  - Data attributes for structured values
  - Element content for display values
  - CSS custom properties (variables) for theme and tokens
- Eliminates client memory stores by default; state is visible and inspectable
  in DevTools.

✅ CSS-in-TS - All styling through css() and composeStyles()

- CSS properties are fully typed with auto-completion.
- Component level utilities for layout and responsive styles.

✅ Three-tier reactivity

- Reactivity tiers:
  1. CSS properties (Tier 1)
  2. Pub/Sub state (Tier 2)
  3. Custom events (Tier 3)

- Tier 1: CSS properties - Instant visual updates via CSS custom properties
  - No JavaScript execution needed
  - Example: Theme switching, accent color changes
- Tier 2: Pub/Sub state - Cross-component communication via lightweight message
  bus
  - Example: Cart updates, form validation
- Tier 3: Custom events - Component-to-component messaging via custom events
  - Example: Notifications, modals

✅ HTMX used, but not exposed - HTMX attributes generated by helpers

- HTMX attributes are generated by helpers; never written directly in app code.
- HTMX is encapsulated by the library; defaults apply automatically.

✅ Collocated APIs - API handlers defined within components

- Components may declare server endpoints alongside their UI, keeping behavior
  and transport close together.
- API definitions are simple tuples: `[method, path, handler]`.

✅ Render function inline props

- Props are parsed and validated inline in the render function using prop
  helpers.

Example:

```tsx
import {
  boolean,
  defineComponent,
  h,
  html,
  number,
  type RouteHandlerFor,
  string,
} from "../mod.ts";
import { err, ok, type Result } from "../lib/result.ts";
import { Button as UIButton } from "../lib/components/button/token-button.ts";

// Using default theme and standard component styles via imports (no inline styles)

// --- Light FP domain (no classes, errors as values) ---
export type Counter = { readonly id: string; readonly count: number };
export type CounterError =
  | { readonly type: "invalid_payload"; readonly message: string }
  | { readonly type: "not_found"; readonly message: string };

const incrementCounter = (c: Counter): Result<Counter, CounterError> =>
  ok({ ...c, count: c.count + 1 });
const resetCounter = (c: Counter): Result<Counter, CounterError> =>
  ok({ ...c, count: 0 });

// Minimal in-memory store for demo purposes
const counters = new Map<string, Counter>();

// --- API handlers colocated with the component ---
const incrementHandler: RouteHandlerFor<"/api/counter/:id/increment"> = async (
  _req,
  params,
) => {
  const current = counters.get(params.id) ?? { id: params.id, count: 0 };
  const next = incrementCounter(current);
  if (!next.ok) return html("<div>Invalid</div>", { status: 400 });
  counters.set(params.id, next.value);
  // Return a small HTML fragment (HTMX swaps it in)
  return html(`<span data-count>${next.value.count}</span>`);
};

const resetHandler: RouteHandlerFor<"/api/counter/:id/reset"> = async (
  _req,
  params,
) => {
  const current = counters.get(params.id) ?? { id: params.id, count: 0 };
  const next = resetCounter(current);
  if (!next.ok) return html("<div>Invalid</div>", { status: 400 });
  counters.set(params.id, next.value);
  return html(`<span data-count>${next.value.count}</span>`);
};

// --- Comprehensive component using SSR, JSX, inline prop parsing, reactivity, and collocated API ---
export const Counter = defineComponent("counter", {
  // Reactivity: DOM events, pub/sub state, lifecycle, and CSS properties
  reactive: {
    on: {
      // Custom event to toggle accent color using CSS custom property
      "ui-lib:toggle-accent":
        `document.documentElement.style.setProperty('--accent', getComputedStyle(document.documentElement).getPropertyValue('--accent')?.trim()==='#4f46e5' ? '#16a34a' : '#4f46e5')`,
    },
    state: {
      // Update count when external state publishes to 'counter:update'
      "counter:update":
        "const el=this.querySelector('[data-count]'); if(el){ el.textContent=String(data.count) }",
    },
    mount: `this.style.setProperty('--accent', '#4f46e5')`,
    inject: true,
  },

  // Use the standard Button component styles (tokens + base styles)
  styles: `${UIButton.injectStyles()}`,

  // API collocated with the component
  api: {
    increment: ["POST", "/api/counter/:id/increment", incrementHandler],
    reset: ["POST", "/api/counter/:id/reset", resetHandler],
  },

  // Inline props parsing and validation via render parameter defaults
  render: (
    {
      id = string(), // required
      label = string("Counter"), // optional with default
      start = number(0), // number coercion
      disabled = boolean(false), // presence boolean
    },
    api,
    classes,
  ) => {
    // Initialize store on first render (SSR-safe, idempotent)
    if (!counters.has(id)) counters.set(id, { id, count: start });

    const attrs = disabled ? { disabled: "true" } : {};

    return (
      <div data-id={id}>
        <span>{label}</span>
        <button class="ui-button ui-button--outline ui-button--md" {...attrs}>
          −
        </button>
        <span data-count>
          {String(counters.get(id)?.count ?? start)}
        </span>
        <button
          class="ui-button ui-button--primary ui-button--md"
          {...api?.increment?.(id)}
          {...attrs}
        >
          +
        </button>
        <button
          class="ui-button ui-button--secondary ui-button--md"
          {...api?.reset?.(id)}
          {...attrs}
        >
          Reset
        </button>
      </div>
    );
  },
});
```

---

These principles work together: JSX makes templates type-safe, SSR delivers HTML
immediately, DOM-native state keeps UIs simple and debuggable, Light FP
encourages pure and testable core logic, and token-driven styling keeps
components customizable without leaking implementation details.
