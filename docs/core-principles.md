DO NOT CHANGE - ONLY manual changes ALLOWED

## Core Principles.

**ui-lib** is an ultra-lightweight, type-safe component library that embraces

✅ SSR-first - Components render on server

- The server returns HTML; clients submit forms or JSON and receive HTML
  fragments in response.
- Works without client-side JavaScript; optional enhancement uses HTMX-style
  attributes generated by helpers.
- No hydration costs; markup is ready to display as delivered.

✅ JSX only - Using h() function and JSX syntax

- Write components and pages using JSX/TSX. The JSX factory is provided by
  ui-lib (`h`).
- The internal render pipeline (e.g., `renderComponent`) is library-only; do not
  call it from application code.
- Outcome: strongly typed, ergonomic, and composable markup.

✅ DOM-native state (the DOM is the source of truth)

- Use:
  - CSS classes for boolean state
  - Data attributes for structured values
  - Element content for display values
  - CSS custom properties (variables) for theme and tokens
- Eliminates client memory stores by default; state is visible and inspectable
  in DevTools.

✅ CSS-in-TS - All styling through css() and composeStyles()

- CSS properties are fully typed with auto-completion.
- Component level utilities for layout and responsive styles.

✅ Three-tier reactivity

- Reactivity tiers:
  1. CSS properties (Tier 1)
  2. Pub/Sub state (Tier 2)
  3. Custom events (Tier 3)

- Tier 1: CSS properties - Instant visual updates via CSS custom properties
  - No JavaScript execution needed
  - Example: Theme switching, accent color changes
- Tier 2: Pub/Sub state - Cross-component communication via lightweight message
  bus
  - Example: Cart updates, form validation
- Tier 3: Custom events - Component-to-component messaging via custom events
  - Example: Notifications, modals

✅ HTMX used, but not exposed - HTMX attributes generated by helpers

- HTMX attributes are generated by helpers; never written directly in app code.
- HTMX is encapsulated by the library; defaults apply automatically.

✅ Collocated APIs - API handlers defined within components

- Components may declare server endpoints alongside their UI, keeping behavior
  and transport close together.
- API definitions are simple tuples: `[method, path, handler]`.

✅ Render function inline props

- Props are parsed and validated inline in the render function using prop
  helpers.

Example:

```tsx
import {
  boolean,
  css,
  defineComponent,
  h,
  hx,
  number,
  post,
  string,
} from "../mod.ts";
import { html } from "../lib/response.ts";
import { ok, type Result } from "../lib/result.ts";
import { Button as UIButton } from "../lib/components/button/token-button.ts";

// --- Light FP domain helpers (no classes, errors as values) ---
type Counter = { readonly id: string; readonly count: number };
type CounterError = { readonly type: "invalid"; readonly message: string };

const store = new Map<string, Counter>();
const ensure = (id: string, start: number): Counter => {
  const initial = store.get(id) ?? { id, count: start };
  if (!store.has(id)) store.set(id, initial);
  return initial;
};

const updateCounter = (
  id: string,
  start: number,
  mutate: (counter: Counter) => Result<Counter, CounterError>,
): Result<Counter, CounterError> => {
  const next = mutate(ensure(id, start));
  if (next.ok) store.set(id, next.value);
  return next;
};

const step = (counter: Counter): Result<Counter, CounterError> =>
  ok({ ...counter, count: counter.count + 1 });
const reset = (counter: Counter): Result<Counter, CounterError> =>
  ok({ ...counter, count: 0 });

// CSS-in-TS styles
const shell = css({
  display: "inline-flex",
  alignItems: "center",
  gap: "0.75rem",
  padding: "0.75rem 1rem",
  borderRadius: "12px",
  border: "1px solid var(--accent, #4f46e5)",
  background: "rgba(79, 70, 229, 0.08)",
});

const buttonStyles = UIButton.injectStyles();

const mergeHx = (markup: string, attrs: string): string => {
  const trimmed = attrs?.trim();
  if (!trimmed) return markup;
  return markup.replace("<button", `<button ${trimmed} `);
};

// --- Component with collocated API, inline props, SSR, and reactivity ---
export const Counter = defineComponent("counter", {
  styles: buttonStyles,
  reactive: {
    on: {
      "ui-lib:toggle-accent":
        "const root=document.documentElement;const next=root.style.getPropertyValue('--accent')?.trim()==='#16a34a'?'#4f46e5':'#16a34a';root.style.setProperty('--accent', next);",
    },
    state: {
      "counter:update":
        "const target=this.querySelector('[data-count]'); if(target){ target.textContent = String(data.count); }",
    },
    mount: "this.style.setProperty('--accent', '#4f46e5')",
    inject: true,
  },

  api: {
    increment: post("/api/counter/:id/increment", async (req, params) => {
      const result = updateCounter(params.id, 0, step);
      if (!result.ok) {
        return html(<span data-count>error</span>, { status: 400 });
      }

      return html(
        <span data-count>{result.value.count}</span>,
      );
    }),
    reset: post("/api/counter/:id/reset", async (_req, params) => {
      const result = updateCounter(params.id, 0, reset);
      if (!result.ok) {
        return html(<span data-count>error</span>, { status: 400 });
      }

      return html(
        <span data-count>{result.value.count}</span>,
      );
    }),
  },

  render: ({
    id = string(),
    label = string("Counter"),
    start = number(0),
    disabled = boolean(false),
  }, api) => {
    const counter = ensure(id, start);
    const target = `[data-id="${id}"] [data-count]`;

    const resetMarkup = mergeHx(
      UIButton({
        variant: "outline",
        size: "md",
        disabled,
        children: "Reset",
      }),
      api?.reset?.(id, hx({ target, swap: "outerHTML" })) ?? "",
    );

    const incrementMarkup = mergeHx(
      UIButton({
        variant: "primary",
        size: "md",
        disabled,
        children: "+",
      }),
      api?.increment?.(id, hx({ target, swap: "outerHTML" })) ?? "",
    );

    return (
      <div class={shell} data-id={id}>
        <span>{label}</span>
        <span dangerouslySetInnerHTML={{ __html: resetMarkup }} />
        <span data-count>{String(counter.count)}</span>
        <span dangerouslySetInnerHTML={{ __html: incrementMarkup }} />
      </div>
    );
  },
});
```

---

These principles work together: JSX makes templates type-safe, SSR delivers HTML
immediately, DOM-native state keeps UIs simple and debuggable, Light FP
encourages pure and testable core logic, and token-driven styling keeps
components customizable without leaking implementation details.
