DO NOT CHANGE - ONLY manual changes ALLOWED

## Core Principles.

**ui-lib** is an ultra-lightweight, type-safe component library that embraces

✅ SSR-first - Components render on server

- The server returns HTML; clients submit forms or JSON and receive HTML
  fragments in response.
- Works without client-side JavaScript; optional enhancement uses HTMX-style
  attributes generated by helpers.
- No hydration costs; markup is ready to display as delivered.

✅ JSX only - Using h() function and JSX syntax

- Write components and pages using JSX/TSX. The JSX factory is provided by
  ui-lib (`h`).
- The internal render pipeline (e.g., `renderComponent`) is library-only; do not
  call it from application code.
- Outcome: strongly typed, ergonomic, and composable markup.

✅ DOM-native state (the DOM is the source of truth)

- Use:
  - CSS classes for boolean state
  - Data attributes for structured values
  - Element content for display values
  - CSS custom properties (variables) for theme and tokens
- Eliminates client memory stores by default; state is visible and inspectable
  in DevTools.

✅ CSS-in-TS - All styling through css() and composeStyles()

- CSS properties are fully typed with auto-completion.
- Component level utilities for layout and responsive styles.

✅ Three-tier reactivity

- Tier 1: CSS properties - Instant visual updates via CSS custom properties
  - No JavaScript execution needed
  - Example: Theme switching, accent color changes
- Tier 2: Pub/Sub state - Cross-component communication via lightweight message
  bus
  - Example: Cart updates, form validation
- Tier 3: Custom events - Component-to-component messaging via custom events
  - Example: Notifications, modals

✅ HTMX used, but not exposed - HTMX attributes generated by library helpers

- HTMX attributes are generated by helpers; from the API definition
- HTMX is encapsulated by the library; defaults apply automatically.

✅ Collocated APIs - API handlers defined within components

- Components may declare server endpoints alongside their UI, keeping behavior
  and transport close together.

✅ Render function inline props

- Props are parsed and validated inline in the render function using prop
  helpers.

Example:

```tsx
import {
  defineComponent,
  h,
  boolean,
  number,
  string,
  post,
} from "../mod.ts"
import { ok, type Result } from "../lib/result.ts"
import { Button } from "../lib/components/button/token-button.ts"

type Counter = { readonly id: string; readonly count: number }
type CounterError = { readonly type: "invalid"; readonly message: string }

const store = new Map<string, Counter>();
const ensure = (id: string, start: number): Counter => {
  const initial = store.get(id) ?? { id, count: start }
  if (!store.has(id)) store.set(id, initial)
  return initial
};

const updateCounter = (
  id: string,
  start: number,
  mutate: (counter: Counter) => Result<Counter, CounterError>,
): Result<Counter, CounterError> => {
  const next = mutate(ensure(id, start))
  if (next.ok) store.set(id, next.value)
  return next
}

const step = (counter: Counter): Result<Counter, CounterError> =>
  ok({ ...counter, count: counter.count + 1 })
const reset = (counter: Counter): Result<Counter, CounterError> =>
  ok({ ...counter, count: 0 })

// --- Define Component with collocated API, inline props, SSR, and reactivity ---
export const Counter = defineComponent("counter", {
  styles: Button.styles,
  reactive: {
    on: {
      "ui-lib:toggle-accent":
        "const root=document.documentElement;const next=root.style.getPropertyValue('--accent')?.trim()==='#16a34a'?'#4f46e5':'#16a34a';root.style.setProperty('--accent', next);",
    },
    state: {
      "counter:update":
        "const target=this.querySelector('[data-count]'); if(target){ target.textContent = String(data.count); }",
    },
    mount: "this.style.setProperty('--accent', '#4f46e5')",
    inject: true,
  },

  api: {
    increment: post("/api/counter/:id/increment", async (req, params) => {
      const result = updateCounter(params.id, 0, step)
      if (!result.ok) {
        return render({}, _api)(<span data-count>error</span>, { status: 400 })
      }
      return render({}, _api)(<span data-count>{result.value.count}</span>, {status: 200})
    }),
    reset: post("/api/counter/:id/reset", async (_req, params) => {
      const result = updateCounter(params.id, 0, reset);
      if (!result.ok) {
        return render({}, _api)(<span data-count>error</span>, { status: 400 })
      }
      return render({}, _api)(
        <span data-count>{result.value.count}</span>, {status: 200})
    }),
  },

  render: ({
    id = string(),
    label = string("Counter"),
    start = number(0),
    disabled = boolean(false),
  }, api) => {
    const counter = ensure(id, start)

    return (
      <div class={shell} data-id={id}>
        <span>{label}</span>
        <ButtonFragment
          variant="outline"
          size="md"
          disabled={disabled}
          children="Reset"
          target = `[data-id="${id}"] [data-count]`
          action={api?.reset?.(id)
        />
        <span data-count>{String(counter.count)}</span>
        <ButtonFragment
          variant="primary"
          size="md"
          disabled={disabled}
          children="+"
          target = `[data-id="${id}"] [data-count]`
          action={api?.increment?.(id)
        />
      </div>
    );
  }
})
```

---

These principles work together: JSX makes templates type-safe, SSR delivers HTML
immediately, DOM-native state keeps UIs simple and debuggable, Light FP
encourages pure and testable core logic, and token-driven styling keeps
components customizable without leaking implementation details.
